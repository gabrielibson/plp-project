options {  JAVA_UNICODE_ESCAPE = true;  DEBUG_PARSER  = true;}PARSER_BEGIN(Imp2Parser)package li2comStruct.plp.li2Struct.parser;import java.util.Vector;import java.io.*;import java.util.List;import java.util.LinkedList;import li2comStruct.plp.li2Struct.*;import li2comStruct.plp.li2Struct.util.*;import li2comStruct.plp.li2Struct.expressao.*;import li2comStruct.plp.li2Struct.expressao.leftExpression.*;import li2comStruct.plp.li2Struct.expressao.binaria.*;import li2comStruct.plp.li2Struct.expressao.unaria.*;import li2comStruct.plp.li2Struct.expressao.valor.*;import li2comStruct.plp.li2Struct.comando.*;import li2comStruct.plp.li2Struct.declaracao.struct.declaracao.*;import li2comStruct.plp.li2Struct.declaracao.struct.instancia.*;import li2comStruct.plp.li2Struct.declaracao.variavel.*;import li2comStruct.plp.li2Struct.declaracao.procedimento.*;import li2comStruct.plp.li2Struct.memoria.*;import li2comStruct.plp.li2Struct.excecao.declaracao.*;import li2comStruct.plp.li2Struct.excecao.execucao.*;import li2comStruct.plp.imperative1.memory.*;import li2comStruct.plp.imperative1.declaration.*;public class Imp2Parser {    public static void main(String args[]) {	    Imp2Parser parser;	    ListaValor entrada = new ListaValor();	    if (args.length == 0) {	    	System.out.println("Imperativa 2 PLP Parser Version 0.0.1:  Reading from standard input . . .");	    	parser = new Imp2Parser(System.in);	    } else{	    	System.out.println("Imperativa 2 PLP Parser Version 0.0.1:  Reading from file " + args[0] + " . . .");	    	try {	    		parser = new Imp2Parser(new java.io.FileInputStream(args[0]));	    	} catch (java.io.FileNotFoundException e) {	        	System.out.println("Java Parser Version 1.0.2:  File " + args[0] + " not found.");	        	return;	    	}	    		    	List valores = new LinkedList();	    	for(int i=1;i<args.length;i++)	    	{	    	 	String parametro = args[i];	    	 		    	 	try { 	    	 		Integer inteiro = Integer.valueOf(parametro);	    	 		valores.add(new ValorInteiro(inteiro.intValue()));	    	 		continue;	    	 	} catch(NumberFormatException e) {	    	 			    	 	}	    	 		    	 	if(parametro.equalsIgnoreCase("true") 	    	 	    || parametro.equalsIgnoreCase("false")) {	    	 		Boolean booleano = Boolean.valueOf(parametro);	    	 		valores.add(new ValorBooleano(booleano.booleanValue()));	    	 	} else {	    	 	    valores.add(new ValorString(parametro));	    	 	}				    	}	    	  entrada = criaListaValor(valores);	    } 	    	    try {            Programa programa = parser.Input();            System.out.println("Imperativa 2 PLP Parser Version 0.0.1:  Imperativa2 program parsed successfully.");                        if(programa.checaTipo(new ContextoCompilacaoImperativa(entrada))) {                ListaValor saida = programa.executar(new ContextoExecucaoImperativa2(entrada));                System.out.println(saida);            }            else {                System.out.println("Erro de tipo");            }        } catch (Exception e) {            System.out.println("Imperativa 2 PLP Parser Version 0.0.1:  Encountered errors during parse.");            e.printStackTrace();        }	}		public static ListaValor criaListaValor(List valores) {		if(valores.size() == 0) {			return new ListaValor();		}			Valor primeiro = (Valor) valores.get(0);		valores.remove(0);		return new ListaValor((li2comStruct.plp.expressions2.expression.Valor)primeiro, criaListaValor(valores));    }}PARSER_END(Imp2Parser)SKIP : /* WHITE SPACE */{  " "| "\t"| "\n"| "\r"| "\f"}SPECIAL_TOKEN : /* COMMENTS */{  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">}TOKEN : /* TOKENS DE EXPRESSOES 1 */{  < AND: "and" >| < OR  : "or" >| < NOT : "not" >| < LENGTH      : "length" > | < TRUE        : "true" >| < FALSE       : "false" >}TOKEN : /* TOKENS DE IMPERATIVA 1 */{  < VAR: "var" >| < COMAND_SKIP: "skip" >| < WHILE: "while" >| < DO: "do" >| < READ: "read" >| < WRITE: "write" >| < WRITE_FILE: "writeFile" >| < READ_FILE: "readFile" >| < IF: "if" >| < THEN: "then" >| < ELSE: "else" >}TOKEN : /* TOKENS DE IMPERATIVA 2 */{  < PROC: "proc" >| < CALL: "call" >| < STRUCT: "struct" >}TOKEN : /* TOKENS DOS POSSï¿½VEIS TIPOS */{  < INT : "int" >| < BOOLEAN  : "boolean" >| < STRING  : "string" >}TOKEN : /* LITERALS */{  < INTEGER_LITERAL:        <DECIMAL_LITERAL> (["l","L"])?      | <HEX_LITERAL> (["l","L"])?      | <OCTAL_LITERAL> (["l","L"])?  >|  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >|  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >|  < #OCTAL_LITERAL: "0" (["0"-"7"])* >|  < STRING_LITERAL:      "\""      (   (~["\"","\\","\n","\r"])        | ("\\"            ( ["n","t","b","r","f","\\","'","\""]            | ["0"-"7"] ( ["0"-"7"] )?            | ["0"-"3"] ["0"-"7"] ["0"-"7"]            )          )      )*      "\""  >}TOKEN : /* IDENTIFIERS */{  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >|  < #LETTER:      [       "\u0024",       "\u0041"-"\u005a",       "\u005f",       "\u0061"-"\u007a",       "\u00c0"-"\u00d6",       "\u00d8"-"\u00f6",       "\u00f8"-"\u00ff",       "\u0100"-"\u1fff",       "\u3040"-"\u318f",       "\u3300"-"\u337f",       "\u3400"-"\u3d2d",       "\u4e00"-"\u9fff",       "\uf900"-"\ufaff"      ]  >|  < #DIGIT:      [       "\u0030"-"\u0039",       "\u0660"-"\u0669",       "\u06f0"-"\u06f9",       "\u0966"-"\u096f",       "\u09e6"-"\u09ef",       "\u0a66"-"\u0a6f",       "\u0ae6"-"\u0aef",       "\u0b66"-"\u0b6f",       "\u0be7"-"\u0bef",       "\u0c66"-"\u0c6f",       "\u0ce6"-"\u0cef",       "\u0d66"-"\u0d6f",       "\u0e50"-"\u0e59",       "\u0ed0"-"\u0ed9",       "\u1040"-"\u1049"      ]  >}TOKEN : /* SEPARATORS */{  < LPAREN: "(" >| < RPAREN: ")" >| < LBRACE: "{" >| < RBRACE: "}" >| < LBRACKET: "[" >| < RBRACKET: "]" >| < SEMICOLON: ";" >| < COMMA: "," >| < DOT: "." >}TOKEN : /* OPERATORS */{  < ATTRIB: ":=" >| < ASSIGN: "=" >| < GT: ">" >| < LT: "<" >| < BANG: "!" >| < TILDE: "~" >| < HOOK: "?" >| < COLON: ":" >| < EQ: "==" >| < LE: "<=" >| < GE: ">=" >| < NE: "!=" >| < SC_OR: "||" >| < SC_AND: "&&" >| < CONCAT: "++" >| < PLUS: "+" >| < MINUS: "-" >| < STAR: "*" >| < SLASH: "/" >| < BIT_AND: "&" >| < BIT_OR: "|" >| < XOR: "^" >| < REM: "%" >}Programa Input() :{     Programa retorno;}{   retorno = PPrograma() <EOF>   { 	return retorno;    }}Programa PPrograma() :{	Comando retorno;}{	retorno = PComando()	{		return new Programa(retorno);	}}/** * Comando::= ComandoSimples | ComandoSequencial **/Comando PComando() :{  Comando retorno;}{  (    LOOKAHEAD(PComandoSimples() < SEMICOLON >)    retorno = PComandoSequencial()  | retorno = PComandoSimples()  )  {    return retorno;  }}/** * ComandoSequencial ::= ComandoSimples ";" Comando **/SequenciaComando PComandoSequencial() :{  Comando c1;  Comando c2;}{  c1 = PComandoSimples() < SEMICOLON > c2 = PComando()  {    return new SequenciaComando(c1, c2);  }}/*  ADICIONADO OU MODIFICADO DA Imperativa1 PARA A Imperativa2  */Comando PComandoSimples() :{	Comando retorno;}{  (    LOOKAHEAD(< COMAND_SKIP >)    retorno = PSkip()  | LOOKAHEAD(< LBRACE >)    retorno = PComandoDeclaracao()  | LOOKAHEAD(< WHILE >)    retorno = PWhile()  | LOOKAHEAD(< IF >)    retorno = PIfThenElse()  | LOOKAHEAD(< READ >  | < WRITE >)    retorno = PIO()  | LOOKAHEAD(PLeftExpression() < ATTRIB >)    retorno = PAtribuicao()  | < LPAREN > retorno = PComando() < RPAREN >  )  {    return retorno;  }}IO PIO() :{	IO retorno;}{	(		  retorno = PRead()		| retorno = PWrite()		| retorno = PWriteFile()		| retorno = PReadFile()	)	{return retorno;}}Read PRead() :{	Id id;}{	<READ> <LPAREN>		id = PId()		   <RPAREN>	{return new Read (id);}}Write PWrite() :{	Expressao exp;}{	<WRITE> <LPAREN>		exp = PExpressao()		   <RPAREN>	{return new Write(exp);}}/** add PLP**/WriteFile PWriteFile():{  Id id;  Valor file;}{  <WRITE_FILE> <LPAREN> id = PId()  <COMMA>  file = PValorString()  <RPAREN>  {    return new WriteFile(id, file);  }}/** add PLP**/ReadFile PReadFile():{  Id id;  Valor key;  Valor file;}{  id = PId() <ASSIGN>  <READ_FILE> <LPAREN>  key = PValorInteiro()  <COMMA>  file = PValorString()  <RPAREN>  {    return new ReadFile(id, key, file);  }}  IfThenElse PIfThenElse() :{	Expressao expressao;	Comando comandoThen;	Comando comandoElse;}{	<IF>		expressao = PExpressao()	<THEN>		comandoThen = PComando()	<ELSE>		comandoElse = PComando()	{return new IfThenElse (expressao, comandoThen, comandoElse);}}While PWhile() :{	Expressao expressao;	Comando comando;}{	<WHILE>		expressao = PExpressao()	<DO>		comando = PComando()	{return new While(expressao, comando);}}Skip PSkip() :{}{	<COMAND_SKIP>	{return new Skip();}}/** add PLP * Atribuicao ::= LeftExpression ":=" Expressao **/Atribuicao PAtribuicao() :{	LeftExpression av;	Expressao exp;}{	av  = PLeftExpression() <ATTRIB> exp = PExpressao()	{		return new Atribuicao(av, exp);	}}/** add PLP * LeftExpression ::= Id | AcessoAtributo **/LeftExpression PLeftExpression() :{  LeftExpression retorno;}{  (    LOOKAHEAD(PAcessoAtributoId())    retorno = PAcessoAtributoId()  | LOOKAHEAD(< IDENTIFIER >)    retorno = PId()  )  {    return retorno;  }}/** add PLP * ... LeftExpression.Id | Id.Id **/AcessoAtributoId PAcessoAtributoId() :{  LeftExpression av;  Id id;}{  (    LOOKAHEAD(< LPAREN >)    < LPAREN > av = PLeftExpression() < RPAREN >  | av = PId()  )  < DOT > id = PId()  {    return new AcessoAtributoId(av, id);  }}Id PId() :{	Token token;}{	token = <IDENTIFIER>	{		return new Id(token.toString());	}}Valor PValorInteiro() :{	Token token;}{	token = <INTEGER_LITERAL>	{		return new ValorInteiro(Integer.parseInt(token.toString()));	}}Valor PValorBooleano() :{}{	  <FALSE> { return new ValorBooleano(false); } 	| <TRUE>  { return new ValorBooleano(true); }}Valor PValorString() :{	Token token;}{	token = <STRING_LITERAL>	{		String tokenStr = token.toString();		tokenStr = tokenStr.substring(1,tokenStr.length()-1);		return new ValorString(tokenStr);	}}Valor PValor() :{	Valor retorno;}{	(      	  retorno = PValorInteiro() 		| retorno = PValorBooleano()		| retorno = PValorString()    )		{		return retorno;	}}Expressao PExpMenos() :{	Expressao retorno;}{	<MINUS> retorno = PExpressao()	{		return new ExpMenos(retorno);	}}Expressao PExpNot() :{	Expressao retorno;}{	<NOT> retorno = PExpressao()	{		return new ExpNot(retorno);	}}Expressao PExpLength() :{	Expressao retorno;}{	<LENGTH> retorno = PExpressao()	{		return new ExpLength(retorno);	}}Expressao PExpPrimaria() :{    Expressao retorno;}{	(  	    retorno = PId()	  | retorno = PValor() 	  | <LPAREN> retorno = PExpressao() <RPAREN>	)	{		return retorno; 	}}Expressao PExpUnaria() :{	Expressao retorno;}{	(	  retorno = PExpMenos()	|	  retorno = PExpNot() 	| 	  retorno = PExpLength()	)	{		return retorno;	}}Expressao PExpBinaria() :{	Expressao retorno, param2;}{	(		  LOOKAHEAD (PExpPrimaria() <CONCAT> )		  	retorno = PExpConcat()		| LOOKAHEAD (PExpPrimaria() <MINUS>)			retorno = PExpSub()		| LOOKAHEAD (PExpPrimaria() <AND>)			retorno = PExpAnd()		| LOOKAHEAD (PExpPrimaria() <OR>)			retorno = PExpOr()		| LOOKAHEAD (PExpPrimaria() <EQ>)			retorno = PExpEquals()		| LOOKAHEAD (PExpPrimaria() <PLUS>)			retorno = PExpSoma()	)	{		return retorno;	}}ExpSoma PExpSoma() :{	Expressao esq;	Expressao dir;}{	esq = PExpPrimaria()	<PLUS>	dir = PExpressao()	{return new ExpSoma(esq, dir);}}ExpSub PExpSub() :{	Expressao esq;	Expressao dir;}{	esq = PExpPrimaria()	<MINUS>	dir = PExpressao()	{return new ExpSub(esq, dir);}}ExpAnd PExpAnd() :{	Expressao esq;	Expressao dir;}{	esq = PExpPrimaria()	<AND>	dir = PExpressao()	{return new ExpAnd(esq, dir);}}ExpOr PExpOr() :{	Expressao esq;	Expressao dir;}{	esq = PExpPrimaria()	<OR>	dir = PExpressao()	{return new ExpOr(esq, dir);}}ExpEquals PExpEquals() :{	Expressao esq;	Expressao dir;}{	esq = PExpPrimaria()	<EQ>	dir = PExpressao()	{return new ExpEquals(esq, dir);}}ExpConcat PExpConcat() :{	Expressao esq;	Expressao dir;}{	esq = PExpPrimaria()	<CONCAT>	dir = PExpressao()	{return new ExpConcat(esq, dir);}}Expressao PExpressao() :{	Expressao retorno;}{	(	    LOOKAHEAD (2) 	  		retorno = PExpUnaria()	  | LOOKAHEAD (PExpPrimaria() (<OR> | <AND> | <MINUS> | <PLUS> | <EQ> | <CONCAT>)) 	  		retorno = PExpBinaria()	  |	    retorno = PExpPrimaria()	)	{		return retorno;	}}ChamadaProcedimento PChamadaProcedimento():{	Id nomeProcedimento;	ListaExpressao parametrosAtuais;}{	<CALL> nomeProcedimento = PId() <LPAREN> parametrosAtuais = PListaExpressao() <RPAREN>	{		return new ChamadaProcedimento(nomeProcedimento, parametrosAtuais);	}}ComandoDeclaracao PComandoDeclaracao() :{	Declaracao dec;	Comando comando;}{	<LBRACE> 		dec = PDeclaracao() <SEMICOLON> comando = PComando() 	<RBRACE> 	{ 		return new ComandoDeclaracao(dec, comando); 	}}Declaracao PDeclaracao():{	Declaracao retorno;}{	(		  LOOKAHEAD(PDeclaracaoVariavel() <COMMA>)           retorno = PDeclaracaoComposta()          |LOOKAHEAD(PDeclaracaoProcedimento() <COMMA>)           retorno = PDeclaracaoComposta()          |LOOKAHEAD(PInstanciaStruct() < COMMA > )           retorno = PDeclaracaoComposta()  		  | retorno = PDeclaracaoVariavel()		  | retorno = PDeclaracaoProcedimento()          | <LPAREN> retorno = PDeclaracao() <RPAREN>          | retorno = PDefStruct()          | retorno = PInstanciaStruct()   		 		  	)	{return retorno;}}/** Add PLP**/DefStruct PDefStruct():{ Id id; DeclaracaoChave chave;  ListaDecAtributoStruct listadecattstruct;}{  <STRUCT> id = PId() <LBRACE> chave = PDeclaracaochave() <SEMICOLON>  listadecattstruct = PListaDecAtributoStruct() <RBRACE>  {    return new DefStruct(id, chave, listadecattstruct);  }}/** Add PLP**/DeclaracaoChave PDeclaracaochave():{  Id id;}  {    <INT>    id = PId()    {       return new DeclaracaoChave(id);  	}  }/*** Producao da Lista de declaracao de atributos do struct**//** Add PLP**/ListaDecAtributoStruct PListaDecAtributoStruct():{	Id id;	Tipo tipo;	ListaDecAtributoStruct lista = null;}{	[ tipo = PTipo() 	  id = PId() 	  { lista = new ListaDecAtributoStruct(new DeclaracaoAtributoStruct(id, tipo));}	] 	( <SEMICOLON> 	  tipo = PTipo() id = PId() 	  {lista = new ListaDecAtributoStruct(new DeclaracaoAtributoStruct(id, tipo), lista);} 	)+		{		if (lista == null) {			lista = new ListaDecAtributoStruct();		}			return lista;	}}/** Add PLP**/InstanciaStruct PInstanciaStruct():{  InstanciaStruct instanciaStruct;}{ 	( 	  	LOOKAHEAD(< IDENTIFIER > )   		instanciaStruct = PInstanciaValoresStruct()  		|instanciaStruct = PInstanciaLeituraStruct()	)  {    return instanciaStruct;  }}/** Add PLP**/InstanciaValoresStruct PInstanciaValoresStruct():{  Tipo tipo;  Id id;  ListaExpressao listaexp;}{  tipo = PTipo()  id = PId()  <ASSIGN> <LBRACKET> listaexp = PListaExpressao() <RBRACKET>  {    return new InstanciaValoresStruct(tipo, id, listaexp);  }}/** Add PLP**/InstanciaLeituraStruct PInstanciaLeituraStruct():{  Tipo tipo;  Id id;  Valor key;  Valor file;}{  tipo = PTipo()  id = PId()  <ASSIGN> <READ_FILE> <LPAREN>  key = PValorInteiro()  <COMMA>  file = PValorString() <RPAREN>  {    return new InstanciaLeituraStruct(tipo, id, key, file);  } }DeclaracaoComposta PDeclaracaoComposta():{	Declaracao d1;	Declaracao d2; }{	(LOOKAHEAD(PDeclaracaoVariavel() <COMMA>)	  d1 = PDeclaracaoVariavel() <COMMA> d2 = PDeclaracao()	 	 |  LOOKAHEAD(PDeclaracaoProcedimento() <COMMA>)	 d1 = PDeclaracaoProcedimento() <COMMA> d2 = PDeclaracao()	)		{return new DeclaracaoComposta(d1, d2);}}DeclaracaoProcedimento PDeclaracaoProcedimento():{	Id nome;	DefProcedimento defProcedimento;}{    (        LOOKAHEAD(<PROC> PId() <LPAREN> <RPAREN>)    	<PROC> nome = PId() <LPAREN> <RPAREN> defProcedimento = PDefProcedimento()    	|    	<PROC> nome = PId() <LPAREN> defProcedimento = PDefProcedimento()    )	{	    return new DeclaracaoProcedimento (nome, defProcedimento);	}}DefProcedimento PDefProcedimento():{	ListaDeclaracaoParametro listaPar = null;	Comando comando;}{    (		<LBRACE> comando = PComando() <RBRACE>	   	| listaPar = PListaDeclaracaoParametro() <RPAREN> <LBRACE> comando = PComando() <RBRACE>    )	{	    if(listaPar == null) {	        listaPar = new ListaDeclaracaoParametro();	    }	    return new DefProcedimento (listaPar, comando);	}	}/**Dividimos Tipo em 2 categorias: TipoPrimitivo e TipoStruct.Qualquer coisa apagar produÃ§Ã£o de PTipo, PTipoPrimitivo e PTipoStruct e descomentar essa parte.**Tipo PTipo():{	Tipo tipo;}{	(	<INT> {tipo = TipoPrimitivo.INTEIRO;} |	<BOOLEAN> {tipo = TipoPrimitivo.BOOLEANO;} |	<STRING> {tipo = TipoPrimitivo.STRING;}	)	{		return tipo;	}}**//** Add PLP**//** * Tipo ::= TipoStruct | TipoPrimitivo **/Tipo PTipo() :{  Tipo tipo;}{  (    LOOKAHEAD(< STRING >  | < INT >  | < BOOLEAN >)    tipo = PTipoPrimitivo()  | tipo = PTipoStruct()  )  {    return tipo;  }}/** Add PLP**//** * TipoPrimitivo ::= "string" | "int" | "boolean" **/Tipo PTipoPrimitivo() :{  Tipo retorno;}{  (    LOOKAHEAD(< INT >)    < INT >    {      retorno = TipoPrimitivo.TIPO_INTEIRO;    }  | LOOKAHEAD(< BOOLEAN >)    < BOOLEAN >    {      retorno = TipoPrimitivo.TIPO_BOOLEANO;    }  | < STRING >    {      retorno = TipoPrimitivo.TIPO_STRING;    }  )  {    return retorno;  }}/** Add PLP**//** * TipoStruct ::= Id **/Tipo PTipoStruct() :{  Tipo retorno;  Id id;}{  (    id = PId()    {      retorno = new TipoStruct(id);    }  )  {    return retorno;  }}ListaDeclaracaoParametro PListaDeclaracaoParametro():{	Id id;	Tipo tipo;	ListaDeclaracaoParametro lista = null;}{	[ tipo = PTipo() 	  id = PId() 	  { lista = new ListaDeclaracaoParametro(new DeclaracaoParametro(id, tipo));}	] 	( <COMMA> 	  tipo = PTipo() id = PId() 	  {lista = new ListaDeclaracaoParametro(new DeclaracaoParametro(id, tipo), lista);} 	)*		{		if (lista == null) {			lista = new ListaDeclaracaoParametro();		}			return lista;	}}ListaExpressao PListaExpressao():{	Expressao exp;	ListaExpressao lista = null;}{	[ exp = PExpressao() { lista = new ListaExpressao(exp); } ]		( <COMMA> exp = PExpressao()			{			  lista = new ListaExpressao(exp, lista);			}	   	)*	{		if (lista == null) {			lista = new ListaExpressao();		}			return lista;	}}DeclaracaoVariavel PDeclaracaoVariavel() :{	Id id;	Expressao exp;	DeclaracaoVariavel retorno;}{	 <VAR> id = PId() <ASSIGN> exp = PExpressao() 	   	{retorno = new DeclaracaoVariavel(id, exp);}	{		return retorno;	}}